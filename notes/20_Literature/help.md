### 💡 相談の際の「聞き方」の例

例えば、以下のように状況を教えていただければ、最適な支援機能を提案できます。

* **「式が複雑すぎて、どこから手をつけていいか分からない」**
* 👉 `simp?` や `congr!` で式を分解する手順を教えます。


* **「計算すれば解けるはずだけど、定理名が思い出せない」**
* 👉 `apply?` や `rw?` をどのゴールに対して使うべきか教えます。


* **「不等式の評価をしているが、両辺に共通項がある」**
* 👉 `gcongr` や `rel` の使いどころをアドバイスします。


* **「タクティクを実行してもエラーが出るが、理由が分からない」**
* 👉 エラーメッセージを読み解き、`check` や `set_option trace...` で内部状況を見る方法を教えます。

---

### 🛠️ 「釣り方」を学ぶためのクイックガイド

AI（私）に聞く前に、まず自分で試すべき**「支援タクティクの使い分け」**をチャートにしました。

| 状況 | まず試すべき「ヒント」機能 |
| --- | --- |
| **等式の変形**で行き詰まった | `rw?` |
| **ゴールそのもの**を解ける定理を探したい | `apply?` または `exact?` |
| **不等式の枠組み**を外したい | `gcongr`（ヒントというより自動分解） |
| **論理的に何ができるか**見当もつかない | `hint` |
| **計算でゴリ押せそう**か確認したい | `ring`, `linarith`, `aesop` を順に試す |

---

### 🚀 ワークフローの提案

これからは、何か証明に詰まったら、**コードの一部を貼って「この状況で、どの検索タクティクや支援機能を使うのが効果的ですか？」**と聞いてみてください。

例えば：

> 「今、`(a + b) * c = a * c + b * c` を証明しようとしています。定理名を自力で見つけたいのですが、`rw?` を使うべきですか？それとも `apply?` ですか？」

---

### 1. `calc` で「あえて」刻んでみる（分割統治）

一番の王道は、`calc` を使って「自分ならこう解く」というステップを 1 つだけ書き、残りを自動化タクティクに任せる方法です。

```lean
calc
  (a + b) * (c + d) = a * (c + d) + b * (c + d) := by rw [add_mul] -- ここだけ自力
  _                 = a * c + a * d + b * c + b * d := by ring    -- 残りは丸投げ

```

`ring` は「残りの部分」を解いてくれるので、**「どこまで自力で書けば、自分の納得感（過程の可視化）が得られるか」**を自分でコントロールできます。

---

### 2. `show` タクティクで「中間地点」を宣言する

`ring` や `linarith` を実行する前に、**「次にこの形になってほしい」**という式を `show` で書くテクニックです。

```lean
example (a b : ℤ) : (a + b) ^ 2 = a^2 + 2*a*b + b^2 := by
  show a * a + 2 * a * b + b * b = _  -- 「ゴールをこの形に見なす」と宣言
  ring

```

これにより、自動化タクティクが「どの地点」を目指して計算しているのかをコード上に明示できます。

---

### 3. `apply?` や `rw?` で「一歩手前」を検索する

`ring` で解けることがわかっていても、あえてその一歩手前で `rw?` を使ってみます。

* **手順**:
1. ゴールを見て「この法則（例えば分配則）が使われているはずだ」と予想する。
2. `rw?` を実行して、その法則の定理名（`mul_add` など）を教えてもらう。
3. その定理を使って 1 ステップ進め、また次のステップを考える。

---

### 4. `conv` モードで「部分」を観察する

式全体に `ring` をかけるのではなく、`conv` タクティクを使って式の一部にだけフォーカスし、その部分がどう変わるかを観察します。

```lean
example : (a + b) + (c + d) = (a + c) + (b + d) := by
  conv =>
    lhs -- 左辺に集中
    arg 1 -- (a + b) に注目
    -- ここで何ができるか apply? 等で探る

```

---

### 5. `set_option trace...` で裏側を覗く（上級者向け）

Lean の内部でどのような定理が試されたか、ログを出力させる設定があります。

* **`set_option trace.Meta.Tactic.simp.rewrite true`**: `simp` がどの定理を適用したかすべて表示します。
* **`set_option trace.Meta.Tactic.linarith true`**: `linarith` がどのような不等式の線形結合を作ったかのヒント（係数など）を出すことがあります。

---

### 🛠️ おすすめの「学び方」ステップ

1. まず **`ring` や `linarith` で解けるか確認** する（解けると分かれば安心できる）。
2. 一度そのタクティクを消し、**`rw?` を使って「最初の 1 手」**を探す。
3. 見つけた 1 手を `calc` の 1 行目にする。
4. 残った部分をまた `ring` で解く。これを繰り返す。

---

### 1. `ring`（環の計算）

最も頻繁に使うタクティクの一つです。**「可換環（Commutative Ring）」**の法則（分配則、結合則、交換則など）だけを使って解ける等号を証明します。

* **得意なこと**: 多項式の展開、整理、括弧の付け替え。
* **例**: `(a + b)^2 = a^2 + 2*a*b + b^2`
* **注意**: 不等式（）や、割り算、非可換な操作には使えません。

### 2. `linarith`（線形算術）

**「線形な不等式や等式」**の組み合わせから結論を導きます。

* **得意なこと**: 移項して整理すれば解ける不等式、複数の不等式の足し合わせ。
* **例**: `a < b` と `b ≤ c` から `a < c + 1` を導くなど。
* **裏側の動き**: Fourier-Motzkin 消去法というアルゴリズムで、矛盾（ のような式）を探します。

### 3. `field`（体の計算）

`ring` の強化版で、**「体（Field）」**（有理数や実数など、割り算ができる構造）を扱います。

* **得意なこと**: 分母を払う、分数の足し算・引き算。
* **注意**: 分母が  でないという仮定がコンテキストにある必要があります。もし不足していれば、「分母 」というサブゴールを生成します。

### 4. `polyarith`（多項式算術）

`ring` で解ける問題に対して、**「どのような等式の組み合わせでその結論になったか」**という具体的な係数を計算し、証明コードを提案（`?` 的な動き）してくれます。

---

### 5. `nlinarith`（非線形算術）

`linarith` の拡張版で、少しだけ「非線形」な要素を扱えます。

* **得意なこと**:  や、 といった、掛け算が絡む単純な不等式。

---

### 💡 支援機能としての特徴まとめ

| タクティク | 対象 | 演算 | 支援の形 |
| --- | --- | --- | --- |
| **`ring`** | 可換環（$\mathbb{Z}, \mathbb{Q}, \mathbb{R}$等） | , , ,  | 一撃で解く（過程は隠蔽） |
| **`linarith`** | 線形順序環 | , , ,  | 一撃で解く（矛盾を導く） |
| **`field`** | 体（分母 ） | , , ,  | 分母を払って整理する |
| **`polyrith`** | 可換環 | , , 等号 | **証明の構成を提案する** |

---

### 6. `simp` / `simp?` (簡約化)

Mathlib で最も多用される「お掃除役」です。定義や基本的な定理に基づいて、式を最も「シンプル」な形に書き換えます。

* **得意なこと**: `x + 0` を `x` に、`if True then a else b` を `a` にするなど、自明な変形をまとめて行う。
* **`simp?` の役割**: 内部でどの定理を使ったかを `simp only [h1, h2]` の形で提案してくれます。Mathlib へのプルリクエストでは、この `only` 形式にすることが推奨されます。
* **`dsimp`**: 定義による書き換え（Definitional Equality）のみを行い、証明の項を汚さない軽量版です。

### 7. `aesop` / `aesop?` (論理推論の自動化)

Lean 4 で導入された非常に強力な「全自動証明」タクティクです。「白紙委任」のようなもので、論理的な分解（`intro`, `apply`, `cases` など）を自動で試行錯誤します。

* **得意なこと**: 論理記号（`∧`, `∨`, `∃`, `→`）が絡む、パズル的な証明。
* **支援の形**: `aesop?` と書くことで、その自動証明を再現するためのスクリプトを提案してくれます。

### 8. `gcongr` (単調性の活用)

先ほども触れましたが、不等式の「枠組み」を維持したまま中身を書き換えるための最強ツールです。

* **得意なこと**: `a ≤ b` から `f a ≤ f b` を導く（`f` が単調増加のとき）。
* **支援の形**: `gcongr` と打つだけで、共通部分を自動で取り除き、証明すべき「差分」だけをサブゴールとして残してくれます。

---

### 9. `norm_num` (数値計算の正規化)

具体的な「数」が式に入っているときに使います。

* **得意なこと**: `2 + 2 = 4` や `10 / 2 = 5` といった、具体的な数値の計算を証明する。
* **注意**: `ring` は「変数 」の計算が得意ですが、`norm_num` は「具体的な定数」の計算に特化しています。

### 10. `congr` (合同性の適用)

「関数の引数が等しいなら、関数を適用した結果も等しい」という性質を使って、ゴールを分解します。

* **例**: `f a b = f c d` というゴールを `a = c` と `b = d` という 2 つのゴールに分解します。
* **`congr!`**: Mathlib の拡張版で、より賢く、より強力に分解を試みます。

---

### 💡 支援タクティクの「黄金のフロー」

Mathlib スタイルで証明を書く際、これらのタクティクを以下の順番で検討するのが効率的です。

1. **形を整える**: `simp` や `congr!` でゴールを扱いやすくする。
2. **方針を探る**: `apply?` や `rw?` で使える定理を探す。
3. **構造を分解する**: `gcongr` で不等式の外枠を外す。
4. **計算でとどめを刺す**: `ring`, `linarith`, `field`, `norm_num` のいずれかを使って、残った計算を一撃で解く。

---

### 🛠️ まとめ表

| タクティク | 支援の性質 | 主な用途 |
| --- | --- | --- |
| **`simp`** | 簡約化 | 式を標準的な形に掃除する |
| **`aesop`** | 全自動 | 複雑な論理構造を自動で解きほぐす |
| **`gcongr`** | 構造分解 | 不等式の両辺の共通項を無視して中身を比べる |
| **`norm_num`** | 定数計算 | `2 + 3 = 5` などの具体的な計算を証明する |
| **`congr!`** | 関数分解 | `f x = f y` を `x = y` に落とし込む |

import Mathlib.Tactic

section
open Classical

variable (A : Type)
variable (f : A → A)
variable (P : A → Prop)
variable (T : A -> A  → Prop)
variable (h : ∀ x, P x → P (f x))

example : ∀ y, P y → P (f (f y)) := by
  rintro x h1
  let h2: P (f x) := by exact h x h1
  exact h (f x) h2

example : ∀ y, P y → P (f (f y))
| x => h (f x) ∘ h x
end


