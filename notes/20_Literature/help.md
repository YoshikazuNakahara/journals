### 💡 相談の際の「聞き方」の例

例えば、以下のように状況を教えていただければ、最適な支援機能を提案できます。

* **「式が複雑すぎて、どこから手をつけていいか分からない」**
* 👉 `simp?` や `congr!` で式を分解する手順を教えます。


* **「計算すれば解けるはずだけど、定理名が思い出せない」**
* 👉 `apply?` や `rw?` をどのゴールに対して使うべきか教えます。


* **「不等式の評価をしているが、両辺に共通項がある」**
* 👉 `gcongr` や `rel` の使いどころをアドバイスします。


* **「タクティクを実行してもエラーが出るが、理由が分からない」**
* 👉 エラーメッセージを読み解き、`check` や `set_option trace...` で内部状況を見る方法を教えます。

---

### 🛠️ 「釣り方」を学ぶためのクイックガイド

AI（私）に聞く前に、まず自分で試すべき**「支援タクティクの使い分け」**をチャートにしました。

| 状況 | まず試すべき「ヒント」機能 |
| --- | --- |
| **等式の変形**で行き詰まった | `rw?` |
| **ゴールそのもの**を解ける定理を探したい | `apply?` または `exact?` |
| **不等式の枠組み**を外したい | `gcongr`（ヒントというより自動分解） |
| **論理的に何ができるか**見当もつかない | `hint` |
| **計算でゴリ押せそう**か確認したい | `ring`, `linarith`, `aesop` を順に試す |

---

### 🚀 ワークフローの提案

これからは、何か証明に詰まったら、**コードの一部を貼って「この状況で、どの検索タクティクや支援機能を使うのが効果的ですか？」**と聞いてみてください。

例えば：

> 「今、`(a + b) * c = a * c + b * c` を証明しようとしています。定理名を自力で見つけたいのですが、`rw?` を使うべきですか？それとも `apply?` ですか？」

といった聞き方をしていただければ、**「なぜそのタクティクが有効なのか」**という理屈も含めて解説します。

--- 

### 1. `ring`（環の計算）

最も頻繁に使うタクティクの一つです。**「可換環（Commutative Ring）」**の法則（分配則、結合則、交換則など）だけを使って解ける等号を証明します。

* **得意なこと**: 多項式の展開、整理、括弧の付け替え。
* **例**: `(a + b)^2 = a^2 + 2*a*b + b^2`
* **注意**: 不等式（）や、割り算、非可換な操作には使えません。

### 2. `linarith`（線形算術）

**「線形な不等式や等式」**の組み合わせから結論を導きます。

* **得意なこと**: 移項して整理すれば解ける不等式、複数の不等式の足し合わせ。
* **例**: `a < b` と `b ≤ c` から `a < c + 1` を導くなど。
* **裏側の動き**: Fourier-Motzkin 消去法というアルゴリズムで、矛盾（ のような式）を探します。

### 3. `field`（体の計算）

`ring` の強化版で、**「体（Field）」**（有理数や実数など、割り算ができる構造）を扱います。

* **得意なこと**: 分母を払う、分数の足し算・引き算。
* **注意**: 分母が  でないという仮定がコンテキストにある必要があります。もし不足していれば、「分母 」というサブゴールを生成します。

### 4. `polyarith`（多項式算術）

`ring` で解ける問題に対して、**「どのような等式の組み合わせでその結論になったか」**という具体的な係数を計算し、証明コードを提案（`?` 的な動き）してくれます。

---

### 5. `nlinarith`（非線形算術）

`linarith` の拡張版で、少しだけ「非線形」な要素を扱えます。

* **得意なこと**:  や、 といった、掛け算が絡む単純な不等式。

---

### 💡 支援機能としての特徴まとめ

| タクティク | 対象 | 演算 | 支援の形 |
| --- | --- | --- | --- |
| **`ring`** | 可換環（$\mathbb{Z}, \mathbb{Q}, \mathbb{R}$等） | , , ,  | 一撃で解く（過程は隠蔽） |
| **`linarith`** | 線形順序環 | , , ,  | 一撃で解く（矛盾を導く） |
| **`field`** | 体（分母 ） | , , ,  | 分母を払って整理する |
| **`polyrith`** | 可換環 | , , 等号 | **証明の構成を提案する** |

---

### 6. `simp` / `simp?` (簡約化)

Mathlib で最も多用される「お掃除役」です。定義や基本的な定理に基づいて、式を最も「シンプル」な形に書き換えます。

* **得意なこと**: `x + 0` を `x` に、`if True then a else b` を `a` にするなど、自明な変形をまとめて行う。
* **`simp?` の役割**: 内部でどの定理を使ったかを `simp only [h1, h2]` の形で提案してくれます。Mathlib へのプルリクエストでは、この `only` 形式にすることが推奨されます。
* **`dsimp`**: 定義による書き換え（Definitional Equality）のみを行い、証明の項を汚さない軽量版です。

### 7. `aesop` / `aesop?` (論理推論の自動化)

Lean 4 で導入された非常に強力な「全自動証明」タクティクです。「白紙委任」のようなもので、論理的な分解（`intro`, `apply`, `cases` など）を自動で試行錯誤します。

* **得意なこと**: 論理記号（`∧`, `∨`, `∃`, `→`）が絡む、パズル的な証明。
* **支援の形**: `aesop?` と書くことで、その自動証明を再現するためのスクリプトを提案してくれます。

### 8. `gcongr` (単調性の活用)

先ほども触れましたが、不等式の「枠組み」を維持したまま中身を書き換えるための最強ツールです。

* **得意なこと**: `a ≤ b` から `f a ≤ f b` を導く（`f` が単調増加のとき）。
* **支援の形**: `gcongr` と打つだけで、共通部分を自動で取り除き、証明すべき「差分」だけをサブゴールとして残してくれます。

---

### 9. `norm_num` (数値計算の正規化)

具体的な「数」が式に入っているときに使います。

* **得意なこと**: `2 + 2 = 4` や `10 / 2 = 5` といった、具体的な数値の計算を証明する。
* **注意**: `ring` は「変数 」の計算が得意ですが、`norm_num` は「具体的な定数」の計算に特化しています。

### 10. `congr` (合同性の適用)

「関数の引数が等しいなら、関数を適用した結果も等しい」という性質を使って、ゴールを分解します。

* **例**: `f a b = f c d` というゴールを `a = c` と `b = d` という 2 つのゴールに分解します。
* **`congr!`**: Mathlib の拡張版で、より賢く、より強力に分解を試みます。

---

### 💡 支援タクティクの「黄金のフロー」

Mathlib スタイルで証明を書く際、これらのタクティクを以下の順番で検討するのが効率的です。

1. **形を整える**: `simp` や `congr!` でゴールを扱いやすくする。
2. **方針を探る**: `apply?` や `rw?` で使える定理を探す。
3. **構造を分解する**: `gcongr` で不等式の外枠を外す。
4. **計算でとどめを刺す**: `ring`, `linarith`, `field`, `norm_num` のいずれかを使って、残った計算を一撃で解く。

---

### 🛠️ まとめ表

| タクティク | 支援の性質 | 主な用途 |
| --- | --- | --- |
| **`simp`** | 簡約化 | 式を標準的な形に掃除する |
| **`aesop`** | 全自動 | 複雑な論理構造を自動で解きほぐす |
| **`gcongr`** | 構造分解 | 不等式の両辺の共通項を無視して中身を比べる |
| **`norm_num`** | 定数計算 | `2 + 3 = 5` などの具体的な計算を証明する |
| **`congr!`** | 関数分解 | `f x = f y` を `x = y` に落とし込む |
