### 💡 相談の際の「聞き方」の例

例えば、以下のように状況を教えていただければ、最適な支援機能を提案できます。

* **「式が複雑すぎて、どこから手をつけていいか分からない」**
* 👉 `simp?` や `congr!` で式を分解する手順を教えます。


* **「計算すれば解けるはずだけど、定理名が思い出せない」**
* 👉 `apply?` や `rw?` をどのゴールに対して使うべきか教えます。


* **「不等式の評価をしているが、両辺に共通項がある」**
* 👉 `gcongr` や `rel` の使いどころをアドバイスします。


* **「タクティクを実行してもエラーが出るが、理由が分からない」**
* 👉 エラーメッセージを読み解き、`check` や `set_option trace...` で内部状況を見る方法を教えます。

---

### 🛠️ 「釣り方」を学ぶためのクイックガイド

AI（私）に聞く前に、まず自分で試すべき**「支援タクティクの使い分け」**をチャートにしました。

| 状況 | まず試すべき「ヒント」機能 |
| --- | --- |
| **等式の変形**で行き詰まった | `rw?` |
| **ゴールそのもの**を解ける定理を探したい | `apply?` または `exact?` |
| **不等式の枠組み**を外したい | `gcongr`（ヒントというより自動分解） |
| **論理的に何ができるか**見当もつかない | `hint` |
| **計算でゴリ押せそう**か確認したい | `ring`, `linarith`, `aesop` を順に試す |

---

### 🚀 ワークフローの提案

これからは、何か証明に詰まったら、**コードの一部を貼って「この状況で、どの検索タクティクや支援機能を使うのが効果的ですか？」**と聞いてみてください。

例えば：

> 「今、`(a + b) * c = a * c + b * c` を証明しようとしています。定理名を自力で見つけたいのですが、`rw?` を使うべきですか？それとも `apply?` ですか？」

---

### 1. `calc` で「あえて」刻んでみる（分割統治）

一番の王道は、`calc` を使って「自分ならこう解く」というステップを 1 つだけ書き、残りを自動化タクティクに任せる方法です。

```lean
calc
  (a + b) * (c + d) = a * (c + d) + b * (c + d) := by rw [add_mul] -- ここだけ自力
  _                 = a * c + a * d + b * c + b * d := by ring    -- 残りは丸投げ

```

`ring` は「残りの部分」を解いてくれるので、**「どこまで自力で書けば、自分の納得感（過程の可視化）が得られるか」**を自分でコントロールできます。

---

### 2. `show` タクティクで「中間地点」を宣言する

`ring` や `linarith` を実行する前に、**「次にこの形になってほしい」**という式を `show` で書くテクニックです。

```lean
example (a b : ℤ) : (a + b) ^ 2 = a^2 + 2*a*b + b^2 := by
  show a * a + 2 * a * b + b * b = _  -- 「ゴールをこの形に見なす」と宣言
  ring

```

これにより、自動化タクティクが「どの地点」を目指して計算しているのかをコード上に明示できます。

---

### 3. `apply?` や `rw?` で「一歩手前」を検索する

`ring` で解けることがわかっていても、あえてその一歩手前で `rw?` を使ってみます。

* **手順**:
1. ゴールを見て「この法則（例えば分配則）が使われているはずだ」と予想する。
2. `rw?` を実行して、その法則の定理名（`mul_add` など）を教えてもらう。
3. その定理を使って 1 ステップ進め、また次のステップを考える。

---

### 4. `conv` モードで「部分」を観察する

式全体に `ring` をかけるのではなく、`conv` タクティクを使って式の一部にだけフォーカスし、その部分がどう変わるかを観察します。

```lean
example : (a + b) + (c + d) = (a + c) + (b + d) := by
  conv =>
    lhs -- 左辺に集中
    arg 1 -- (a + b) に注目
    -- ここで何ができるか apply? 等で探る

```

---

### 5. `set_option trace...` で裏側を覗く（上級者向け）

Lean の内部でどのような定理が試されたか、ログを出力させる設定があります。

* **`set_option trace.Meta.Tactic.simp.rewrite true`**: `simp` がどの定理を適用したかすべて表示します。
* **`set_option trace.Meta.Tactic.linarith true`**: `linarith` がどのような不等式の線形結合を作ったかのヒント（係数など）を出すことがあります。

---

### 🛠️ おすすめの「学び方」ステップ

1. まず **`ring` や `linarith` で解けるか確認** する（解けると分かれば安心できる）。
2. 一度そのタクティクを消し、**`rw?` を使って「最初の 1 手」**を探す。
3. 見つけた 1 手を `calc` の 1 行目にする。
4. 残った部分をまた `ring` で解く。これを繰り返す。

---

### 1. `ring`（環の計算）

最も頻繁に使うタクティクの一つです。**「可換環（Commutative Ring）」**の法則（分配則、結合則、交換則など）だけを使って解ける等号を証明します。

* **得意なこと**: 多項式の展開、整理、括弧の付け替え。
* **例**: `(a + b)^2 = a^2 + 2*a*b + b^2`
* **注意**: 不等式（）や、割り算、非可換な操作には使えません。

### 2. `linarith`（線形算術）

**「線形な不等式や等式」**の組み合わせから結論を導きます。

* **得意なこと**: 移項して整理すれば解ける不等式、複数の不等式の足し合わせ。
* **例**: `a < b` と `b ≤ c` から `a < c + 1` を導くなど。
* **裏側の動き**: Fourier-Motzkin 消去法というアルゴリズムで、矛盾（ のような式）を探します。

### 3. `field`（体の計算）

`ring` の強化版で、**「体（Field）」**（有理数や実数など、割り算ができる構造）を扱います。

* **得意なこと**: 分母を払う、分数の足し算・引き算。
* **注意**: 分母が  でないという仮定がコンテキストにある必要があります。もし不足していれば、「分母 」というサブゴールを生成します。

### 4. `polyarith`（多項式算術）

`ring` で解ける問題に対して、**「どのような等式の組み合わせでその結論になったか」**という具体的な係数を計算し、証明コードを提案（`?` 的な動き）してくれます。

---

### 5. `nlinarith`（非線形算術）

`linarith` の拡張版で、少しだけ「非線形」な要素を扱えます。

* **得意なこと**:  や、 といった、掛け算が絡む単純な不等式。

---

### 💡 支援機能としての特徴まとめ

| タクティク | 対象 | 演算 | 支援の形 |
| --- | --- | --- | --- |
| **`ring`** | 可換環（$\mathbb{Z}, \mathbb{Q}, \mathbb{R}$等） | , , ,  | 一撃で解く（過程は隠蔽） |
| **`linarith`** | 線形順序環 | , , ,  | 一撃で解く（矛盾を導く） |
| **`field`** | 体（分母 ） | , , ,  | 分母を払って整理する |
| **`polyrith`** | 可換環 | , , 等号 | **証明の構成を提案する** |

---

### 6. `simp` / `simp?` (簡約化)

Mathlib で最も多用される「お掃除役」です。定義や基本的な定理に基づいて、式を最も「シンプル」な形に書き換えます。

* **得意なこと**: `x + 0` を `x` に、`if True then a else b` を `a` にするなど、自明な変形をまとめて行う。
* **`simp?` の役割**: 内部でどの定理を使ったかを `simp only [h1, h2]` の形で提案してくれます。Mathlib へのプルリクエストでは、この `only` 形式にすることが推奨されます。
* **`dsimp`**: 定義による書き換え（Definitional Equality）のみを行い、証明の項を汚さない軽量版です。

### 7. `aesop` / `aesop?` (論理推論の自動化)

Lean 4 で導入された非常に強力な「全自動証明」タクティクです。「白紙委任」のようなもので、論理的な分解（`intro`, `apply`, `cases` など）を自動で試行錯誤します。

* **得意なこと**: 論理記号（`∧`, `∨`, `∃`, `→`）が絡む、パズル的な証明。
* **支援の形**: `aesop?` と書くことで、その自動証明を再現するためのスクリプトを提案してくれます。

### 8. `gcongr` (単調性の活用)

先ほども触れましたが、不等式の「枠組み」を維持したまま中身を書き換えるための最強ツールです。

* **得意なこと**: `a ≤ b` から `f a ≤ f b` を導く（`f` が単調増加のとき）。
* **支援の形**: `gcongr` と打つだけで、共通部分を自動で取り除き、証明すべき「差分」だけをサブゴールとして残してくれます。

---

### 9. `norm_num` (数値計算の正規化)

具体的な「数」が式に入っているときに使います。

* **得意なこと**: `2 + 2 = 4` や `10 / 2 = 5` といった、具体的な数値の計算を証明する。
* **注意**: `ring` は「変数 」の計算が得意ですが、`norm_num` は「具体的な定数」の計算に特化しています。

### 10. `congr` (合同性の適用)

「関数の引数が等しいなら、関数を適用した結果も等しい」という性質を使って、ゴールを分解します。

* **例**: `f a b = f c d` というゴールを `a = c` と `b = d` という 2 つのゴールに分解します。
* **`congr!`**: Mathlib の拡張版で、より賢く、より強力に分解を試みます。

---

### 💡 支援タクティクの「黄金のフロー」

Mathlib スタイルで証明を書く際、これらのタクティクを以下の順番で検討するのが効率的です。

1. **形を整える**: `simp` や `congr!` でゴールを扱いやすくする。
2. **方針を探る**: `apply?` や `rw?` で使える定理を探す。
3. **構造を分解する**: `gcongr` で不等式の外枠を外す。
4. **計算でとどめを刺す**: `ring`, `linarith`, `field`, `norm_num` のいずれかを使って、残った計算を一撃で解く。

---

### 🛠️ まとめ表

| タクティク | 支援の性質 | 主な用途 |
| --- | --- | --- |
| **`simp`** | 簡約化 | 式を標準的な形に掃除する |
| **`aesop`** | 全自動 | 複雑な論理構造を自動で解きほぐす |
| **`gcongr`** | 構造分解 | 不等式の両辺の共通項を無視して中身を比べる |
| **`norm_num`** | 定数計算 | `2 + 3 = 5` などの具体的な計算を証明する |
| **`congr!`** | 関数分解 | `f x = f y` を `x = y` に落とし込む |

```lean
import Mathlib.Tactic

section
open Classical

variable (A : Type)
variable (f : A → A)
variable (P : A → Prop)
variable (T : A -> A  → Prop)
variable (h : ∀ x, P x → P (f x))

example : ∀ y, P y → P (f (f y)) := by
  rintro x h1
  let h2: P (f x) := by exact h x h1
  exact h (f x) h2

example : ∀ y, P y → P (f (f y))
| x => h (f x) ∘ h x
end
```

---

### 1. 難しさの正体：「関数の入れ子」と「変数管理」

タクティクモード（`intro`, `apply`）では、Leanが裏側で変数の名前や型を管理してくれますが、項モードではそれらすべてを自分で記述する必要があります。

* **全称記号 ()**: 項モードでは単なる **「関数（-abstraction）」** です。
* `intro x` は、項モードでは `fun x ↦ ...` に相当します。


* **存在記号 ()**: 項モードでは **「構造体（依存ペア）」** です。
* `use x` は、項モードでは `⟨x, proof_of_Px⟩` という括弧（anonymous constructor）で包む必要があります。


* **含意 ()**: これも項モードでは **「関数」** です。
* 「証拠を受け取って、別の証拠を返す」という処理を頭の中でシミュレートしなければなりません。

---

### 2. 項モードを攻略する「翻訳」のコツ

難易度を下げるために、タクティクでの操作を以下のように「脳内変換」すると見通しが良くなります。

| タクティク | 項モードの「正体」 | イメージ |
| --- | --- | --- |
| `intro x` | `fun x ↦` | 新しい変数を引数に取る関数を作る |
| `apply h` | `h (...)` | 関数 `h` に引数を渡して実行する |
| `have h2 := ...` | `let h2 := ...` | 計算の途中の結果に名前をつける |
| `use x` | `⟨x, ...⟩` | 値と証明をセットにしたペアを作る |
| `cases h` | `match h with | ⟨x, px⟩ =>` |

---

### 3. 項モードが「パズル」から「設計」へ変わる瞬間

述語論理の項モードが難しく感じるのは、**「型（Type）」と「命題（Prop）」の境界がなくなる**からです。

例えば `(h : ∀ x, P x)` という前提があるとき、`h x` と書くことは、「関数 `h` に値 `x` を放り込んで、`P x` という結果を取り出す」というプログラミングそのものです。この**「証明を組み立てる＝プログラムを書く」**という感覚（カリー＝ハワード同型対応）に慣れるまでは、パズルのピースが多すぎて混乱しがちです。

---

### 💡 対策：複雑なときは `let` で刻む

一度に巨大な項を書こうとするとエラーの場所すらわからなくなります。述語論理では `let` を多用して、一段階ずつ証拠を作っていくのが Lean Mathlib スタイルのコツです。

```lean
-- 一気に書こうとすると難しい
fun h_ex ↦ match h_ex with | ⟨x, px⟩ => h_univ x px

-- let で刻むと、タクティクに近い感覚で書ける
fun h_ex ↦
  let ⟨x, px⟩ := h_ex
  let h_res := h_univ x px
  h_res

```

---

```lean
import Mathlib.Tactic

-- 命題を反証する：ある特定の A, P, Q のもとで、この含意は成り立たない
example : ¬ (∀ {A : Type} {P Q : A → Prop}, (∀ y, ∃ x, P x → Q y) → ((∃ x, P x) → ∀ y, Q y)) := by
  -- 1. 「もしこの命題が常に真（h_all）なら矛盾する」ことを示す
  intro h_all
  
  -- 2. 具体的な反例のモデルを定義する
  let A := Bool
  let p (b : Bool) : Prop := (b = true)  -- trueはP、falseはPでない
  let q (_ : Bool) : Prop := False       -- 誰もQではない
  
  -- 3. この反例モデルを h_all に適用して、具体的な含意を取り出す
  -- h_spec : (∀ y, ∃ x, p x → q y) → ((∃ x, p x) → ∀ y, q y)
  let h_spec := h_all (A := A) (P := p) (Q := q)
  
  -- 4. 前提 (∀ y, ∃ x, p x → q y) がこのモデルで「真」であることを示す
  have h_premise : ∀ y : Bool, ∃ x : Bool, p x → q y := by
    intro y
    -- x として false を選べば、p false は「偽」なので、ならばは常に「真」
    use false
    intro (hp_false : false = true)
    -- false = true という矛盾した仮定からは何でも導ける
    nomatch hp_false
    
  -- 5. 結論の「ならば」の左側 (∃ x, p x) が「真」であることを示す
  have h_exists_p : ∃ x : Bool, p x := by
    use true
    rfl -- true = true は定義より自明
    
  -- 6. h_spec にこれらを流し込むと、「∀ y, q y」が導かれてしまう
  let h_forall_q : ∀ y : Bool, q y := h_spec h_premise h_exists_p
  
  -- 7. しかし q false は False と定義したので、ここで矛盾が発生！
  -- h_forall_q false : False
  exact h_forall_q false

```

---

### この証明のポイント（学びのポイント）

1. **`let A := Bool`**:
抽象的な型 `A` に、具体的な「2つの要素を持つ型」を代入しています。反例を作る際、`Bool`（`true` と `false`）は非常に便利です。
2. **`p x := (x = true)`**:
「一部の人は  だが、一部の人は  ではない」という状況を `x = true` という定義で作りました。
3. **`use false` (Step 4)**:
ここが最大の急所です。前提の `∃ x, P x → Q y` において、**「 ではない人（）」を一人連れてくるだけで、前提全体を真にできてしまう**（ が何であろうと関係なくなる）ことを突いています。
4. **`nomatch` / `rfl**`:

自動化タクティクを駆使する場合の「現代的な Mathlib スタイル」を解説します。

「足場を探す」という観点では、**`simp` で定義をバラし、`aesop` や `tauto` で論理的な隙間を埋める**のが王道です。これらを使うと、先ほどの「一歩ずつ」の証明が驚くほど短くなります。

---

### 回答の概要

1. **`simp [A]`**: `A` の定義（`if-then-else`）と集合の定義を一度に展開し、自明な項を整理します。
2. **`aesop` (Automated Extensible Search Over Proofs)**:
* `intro`, `apply`, `cases` などの論理操作を全自動で探索します。
* 「誰かが存在するはずだ」「ならばそれを持ってこよう」という推論を代行してくれます。


3. **`fin_cases`**: `Fin 2` のような小さな型の有限個の場合分けを一瞬で終わらせます。

---

### 自動化を極めた最短の証明例

Mathlib のスタイルガイド [2026-02-08] に基づき、可読性と短さを両立させたコードです。

```lean
import Mathlib.Tactic

-- A の定義を simp で使いやすくするため、属性を付与するか simp に渡す
def A (i j : Fin 2) : Set ℕ :=
  if i = j then {0} else ∅

/-- 1. 右辺： aesop 一発で解決 -/
lemma mem_iInter_iUnion_example_auto : 0 ∈ ⋂ j : Fin 2, ⋃ i : Fin 2, A i j := by
  -- A の定義を展開し、論理探索を行う
  aesop (add simp A)

/-- 2. 左辺： fin_cases で構造的に解く -/
lemma not_mem_iUnion_iInter_example_auto : 0 ∉ ⋃ i : Fin 2, ⋂ j : Fin 2, A i j := by
  simp [A]
  intro i hi
  -- i が 0 か 1 かを自動で場合分け
  fin_cases i
  · -- i = 0 のとき、j = 1 を見れば矛盾することを一瞬で指摘
    exact (hi 1).elim
  · -- i = 1 のとき、j = 0 を見れば矛盾
    exact (hi 0).elim

/-- 3. 結論： tauto で論理を閉じる -/
theorem distribution_counterexample_auto :
    ¬ (⋂ j : Fin 2, ⋃ i : Fin 2, A i j ⊆ ⋃ i : Fin 2, ⋂ j : Fin 2, A i j) := by
  -- 補題を組み合わせて矛盾を導く論理を自動化
  tauto [mem_iInter_iUnion_example_auto, not_mem_iUnion_iInter_example_auto]

```

---

### 「足場」を見つけるためのテクニック

自動化を使うとき、何が起きているか分からなくなった場合の対処法（足場の探し方）がいくつかあります。

* **`simp?`**: `simp` が内部でどの補題を使ったかを表示してくれます。これをコピーして貼り付けることで、ブラックボックスを「明示的な証明」に置き換えられます。
* **`aesop?`**: `aesop` が見つけた証明のステップをタクティクとして出力してくれます。
* **`apply?` / `exact?**`: 「今ある仮定から、この結論を導けるライブラリの定理はないか？」を検索してくれます。

---

### Mathlib スタイルのポイント

* **`hi.elim`**: `0 ∈ ∅` という仮定 `hi` があるとき、`False.elim` を呼び出す代わりに `.elim` と書くだけで「空集合に属するなんてありえない」と一蹴できます。
* **`fin_cases`**: 手動で `match i with` と書くよりも、Mathlib ではこのタクティクが標準的です。

自動化を使うと、「どう解くか」よりも「どの補題を組み合わせるか」という**パズル感覚**が強くなります。

次は、**`simp?` などの「提案機能」を使って、自動化から厳密なコードを生成する過程**を実際に体験してみますか？
Lean特有のタクティクです。`nomatch` は「起こり得ない状況（`false = true`）」を却下し、`rfl` は「同じものの等号」を確認します。

---

