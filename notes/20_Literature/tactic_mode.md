## 🛠️ タクティク・モード：ゴール別・意思決定ガイド（古典論理対応版）

### 1. ゴールの形から次のタクティクを決める

| ゴールの形 (`⊢`) | 打つべきタクティク | 意味・効果 |
| --- | --- | --- |
| P→Q (ならば) | `intro h` | 前提  を仮定（武器）に入れる。 |
| P∧Q (かつ) | `constructor` | ゴールを P と Q の2つに分ける。 |
| P↔Q (同値) | `constructor` | 双方向の証明に分ける。 |
| P∨Q (または） | `left` / `right` | 証明できそうな側を自分で選ぶ。 |
| ¬P (否定) | `intro h` | ゴールを `False` に変える（直説法的な否定の導入）。 |
| P (単一の命題) | `apply h` | 仮定 h:A→P があれば、ゴールを A に変えて逆算する。 |
| **詰まったら** | **`apply by_contra`** | **背理法を開始**。ゴールを否定して `False` を目指す。 |

サブゴールを整理する：ドット · のルール
constructor や cases を使った直後は、迷わず以下のフォーマットで書き始めてください。これが「視界」をクリアにする最大のコツです。

```lean
  constructor
  · -- ここに1つ目のゴールの証明を書く
    exact ...
  · -- ここに2つ目のゴールの証明を書く
    exact ...
```
迷わないコツ: ドット · の中では、そのゴールが消えるまで他のゴールのことは一切考えなくて済みます。

---

### 2. 「仮定（手持ちの武器）」をどう使うか

ゴールが動かない時は、手元の仮定 `h` を見て次の操作を決めます。

| 仮定の形 | 打つべきタクティク | 効果 |
| --- | --- | --- |
| h:P∧Q | `cases h with | intro h1 h2` |
| h:P∨Q | `cases h with | inl h1 => |
| h:P→Q | `apply h` | ゴールを Q から P に逆算する。 |
| **何もできない** | **`by_cases h : P`** | **排中律を使用**。「 か  か」で場合分けする。 |

---

## 📝 古典論理の使用例：具体的な判断基準

### 例①：背理法 (`by_contra`)

「 を証明したいが、手元に  を作る方法が一つもない」という絶望的な状況で使います。

```lean
example (A : Prop) : ¬¬A → A := by
  intro hnnA
  -- ゴール A を作る直接的な方法がない！
  apply by_contra
  -- ゴールが False になり、仮定に hna : ¬A が追加される
  intro hna
  exact hnnA hna -- ¬¬A は ¬A → False なので、hna を渡せば矛盾が完成！

```

### 例②：排中律 (`by_cases`)

「 という情報さえあれば進めるのに、 が真か偽か分からない」という時に、世界を二つに割ります。

```lean
-- ピアースの律: ((P → Q) → P) → P
example (P Q : Prop) : ((P → Q) → P) → P := by
  intro h
  -- P か ¬P かで場合分けを強行する
  by_cases hp : P
  · exact hp -- P が真なら、ゴール P は既に解決！
  · -- P が偽（¬P）の場合
    apply h
    intro hp_in
    -- hp_in : P と hp : ¬P が矛盾するので、爆発原理で Q を出す
    contradiction 

```

---

## 💡 迷わないための「最終デバッグ・フロー」

1. **分解フェーズ**: `intro`, `constructor`, `cases` を使い、ゴールと仮定を最小単位までバラす。
2. **前進フェーズ**: `apply` や `exact` で、手持ちの武器をゴールにぶつける。
3. **古典フェーズ (行き詰まったら)**:
* ゴールが単一の命題で、どうしようもなければ `apply by_contra`。
* 仮定の情報が足りず、特定の命題の真偽で状況が変わりそうなら `by_cases`。
4. **レスキュー**: それでもダメなら `apply?` で定理を検索するか、`tauto` で自明か確認する。

---

このガイドを使っていても迷いが生じたときは、Infoviewで以下の2箇所をチェックしてください。

1. **「矛盾」を探す**:
仮定の中に `h1 : P` と `h2 : ¬P` が同時に存在している（あるいは `h1 : P` があるのにゴールが `False` である）場合、迷わず **`contradiction`** と打ちましょう。パズルがそこで終了します。
2. **「逆算」の落とし穴**:
`apply h` をすると、ゴールが「」から「 を導くための前提 」に変わります。もし「 を証明するほうが難しそうだ」と感じたら、一旦 `undo`（Ctrl+Z）して、別の武器（`cases` など）を試しましょう。

---
