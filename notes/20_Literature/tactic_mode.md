## 🛠️ 命題論理のタクティク対応表

| 論理記号 | 導入則 (ゴールを分解) | 除去則 (仮定を使う) |
| --- | --- | --- |
| **ならば ()** | `intro h` | `apply f` または `have h := f ha` |
| **かつ ()** | `constructor` | `cases h with |
| **または ()** | `left` / `right` | `cases h with |
| **同値 ()** | `constructor` | `rw [h]` または `apply h.mp` |
| **否定 ()** | `intro h` (ゴールを `False` に) | `apply h` (矛盾を導く) |
| **偽 ()** | (なし) | `contradiction` または `nomatch h` |

---

### 1. ならば () と 否定 ()

タクティクでは、これらは「仮定を増やす」操作になります。

* **導入 (`intro`)**: ゴールの左側の条件を仮定（Hypothesis）に引き込みます。
* **除去 (`apply`)**: 「 を証明せよ」というゴールを、「 を使って、 の証明」にすり替えます。

```lean
example (A B : Prop) : A → (A → B) → B := by
  intro ha f  -- 仮定 ha : A と f : A → B を作る
  apply f     -- ゴールを B から A に変える（逆算）
  exact ha    -- 手持ちの ha で解決

```

### 2. かつ () と 同値 ()

これらは「二つのことを同時に扱う」ための操作です。

* **導入 (`constructor`)**: ゴールを2つのサブゴールに分割します。
* **除去 (`cases`)**: 1つの仮定を2つの独立した仮定に分解します。

```lean
example (h : A ∧ B) : B ∧ A := by
  cases h with | intro ha hb => -- h を ha と hb に分解
  constructor                   -- ゴールを B と A に分ける
  · exact hb
  · exact ha

```

### 3. または ()

「どちらか一方が言えれば良い」という性質を操作します。

* **導入 (`left` / `right`)**: ゴールをどちらか一方に絞ります。
* **除去 (`cases`)**: 「 の場合」と「 の場合」で証明を分岐（ケース割）させます。

```lean
example (h : A ∨ B) : B ∨ A := by
  cases h with
  | inl ha => right; exact ha -- A の場合：右側(A)を証明
  | inr hb => left; exact hb  -- B の場合：左側(B)を証明

```

---

### 4. 古典論理（Classical）

タクティク・モードでは、直感的な名前のタクティクが用意されています。

* **排中律 (`by_cases`)**: 特定の命題  について、「 が真の場合」と「 が偽の場合」で分岐させます。
* `by_cases h : P`


* **背理法 (`by_contra`)**: ゴールを否定し、矛盾 (`False`) を導くモードに切り替えます。
* `by_contra h`



---

### 💡 タクティク・モード特有のデバッグテクニック

タクティク・モードで迷ったときは、以下の「攻め方」を意識してください。

1. **ゴールが複雑ならバラす**: `intro` や `constructor` でゴールをシンプルにする。
2. **仮定が複雑ならバラす**: `cases` で `h` を中身のパーツに分解する。
3. **行き詰まったら検索**: `apply?` を打てば、今の仮定を使ってゴールを解決できる定理を Lean が探してくれます。
4. **自動化に投げる**: 命題論理のパズルなら `tauto` で一撃です。

---
