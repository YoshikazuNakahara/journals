## 命題論理の項モード対応表

| 論理記号 | 導入則 (作り方) | 除去則 (使い方) |
| --- | --- | --- |
| **ならば ()** | `fun h ↦ ...` | `f h` (関数適用) |
| **かつ ()** | `⟨h1, h2⟩` | `h.left`, `h.right` |
| **または ()** | `Or.inl h`, `Or.inr h` | `h.elim (fun h1 ↦ ...) (fun h2 ↦ ...)` |
| **同値 ()** | `⟨h_mp, h_mpr⟩` | `h.mp`, `h.mpr` |
| **否定 ()** | `fun h ↦ ...` (矛盾へ) | `h h_val` (矛盾を導く) |
| **偽 ()** | (なし) | `h.elim` (爆発原理) |

---

### 1. ならば () と 否定 ()

型理論において、 は  と定義されるため、使い方は同じです。

* **導入**: 仮定（引数）を受け取る関数を書く。
* **除去**: 手持ちの関数に、必要な引数を渡す。

```lean
-- 導入
def intro_imp (A B : Prop) : A → B := fun ha ↦ _ 

-- 除去
example (A B : Prop) (f : A → B) (ha : A) : B := f ha

```

### 2. かつ () と 同値 ()

これらは「複数の証拠をまとめた構造体」です。

* **導入**: 山括弧 `⟨ ⟩` で包む。
* **除去**: ドット記法で中身を取り出す。

```lean
-- 導入
example (hA : A) (hB : B) : A ∧ B := ⟨hA, hB⟩

-- 除去
example (h : A ∧ B) : A := h.left

```

### 3. または ()

「どちらか一方」なので、作る時はどちらか選び、使う時は両方のケースを想定します。

* **導入**: 左 (`inl`) か 右 (`inr`) かを指定する。
* **除去**: `elim` を使い、それぞれのケースに対する関数を2つ用意する。

```lean
-- 導入
example (hA : A) : A ∨ B := Or.inl hA

-- 除去
example (h : A ∨ B) (fA : A → C) (fB : B → C) : C := 
  h.elim (fun ha ↦ fA ha) (fun hb ↦ fB hb)

```

---

### 4. 古典論理（Classical）

第6章で登場した、特別な「作り方」です。

* **排中律 (`em`)**: 証拠がなくても `em A` と書くだけで `A ∨ ¬A` という証拠（構造体）が手に入ります。
* **背理法 (`by_contra`)**: 「 ならば矛盾」という関数を引数に渡すと、強引に  を作り出します。

---

### デバッグに役立つヒント

項モードで書いているとき、「除去則」を使おうとして `h.` と打つと、その型で使える除去用の関数（`left`, `right`, `elim`, `mp` など）が補完リストにずらっと並びます。

* **「作りたい型」** を見て導入則（`fun`, `⟨ ⟩`, `Or.inl`）を選ぶ。
* **「持っている型」** を見て除去則（`.left`, `.elim`, `f h`）を選ぶ。

このパズルが組み合わさった瞬間、`sorry` が消えて証明が完成します。
