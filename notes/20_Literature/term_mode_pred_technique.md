## 1. デバッグ：一階述語論理特有の対話テクニック

### ① Placeholder (`_`) と「値」の推論

存在記号の導入 `⟨_, _⟩` では、1つ目の穴には「具体的な値」を入れますが、Leanに推論を任せられる場合があります。

* **具体例**: `h : P a` がある状態で `∃ x, P x` を示す

```lean
example (a : U) (h : P a) : ∃ x, P x :=
  ⟨_, h⟩ -- 1つ目を _ にすると、Infoviewに「Expected: U」と出ますが、
         -- h の型 (P a) を見て、Leanが自動的に _ = a と解釈してくれます。

```

### ② インライン `by apply?` の強力さ

全称記号の除去などで、どの順番で引数を渡せばいいか混乱した時、`(by apply?)` は「値」と「証明」を適切に並べた項を提案してくれます。

---

## 2. 磨き上げ：Mathlibスタイル（一階述語論理版）

ここが最も「熟練者」の差が出る部分です。

### ① 存在記号のフラット化（Nested ⟨ ⟩）

「かつ ()」と同様、多重の存在記号もフラットに書けます。

* **Before**: `⟨x, ⟨y, ⟨z, hpxyz⟩⟩⟩`
* **After**: `⟨x, y, z, hpxyz⟩`

> **意図**: 「 という証拠品と、その性質の証明」という一連のデータを一塊として扱います。

### ② ドット記法による「全称記号の除去」

全称記号 `h : ∀ x, P x` は関数なので、通常 `h a` と書きますが、Mathlibではドット記法を組み合わせて鎖（Chain）のように書くことがあります。

* **例**: `(h x).left`

> **意味**: 「 に  を適用して得られた『かつ』の証明の、左側を取り出す」

### ③ 無名引数 `‹ ›` による「値」の参照

`‹ ›` は命題だけでなく、**その型に属する値**も拾えます。

* **具体例**:

```lean
variable (U : Type) (P : U → Prop)
example (a : U) (h : ∀ x, P x) : P a :=
  h ‹U› -- 今コンテキストにある U 型の要素（つまり a）を探して適用せよ

```

> ※ ただし、コンテキストに同じ型の値が複数あるとエラーになるため、値（）については明示的に名前を書く方が一般的です。

---

## 3. 一階述語論理の「黄金のルーチン」拡張版

一階述語論理での「磨き上げ」の最終形は、以下のようになります。

```lean
-- 演習 9.7.2 より：(∀ x, A x ∧ B x) → ∀ x, A x
example (h : ∀ x, A x ∧ B x) : ∀ x, A x :=
  fun x ↦ (h x).left

```

1. **Skeleton**: `fun x ↦ _`
2. **Inspect**: `_` の位置で `Expected type: A x` を確認。
3. **Refine**: 手元の `h` は `∀` なので、とりあえず `x` を食わせる → `h x` は `A x ∧ B x` 型。
4. **Polish**: `(h x).left` で完成。

---

### 1. `exact?`：一階述語論理での凄み

命題論理では `exact?` は単なるパズルのピース探しでしたが、一階述語論理では**「適切な値（証拠品）を自動で見つけてきてくれる」**ツールに進化します。

* **具体例**: `h : P a` があるとき、ゴール `∃ x, P x` に対して `exact?` を使う。
* **Leanの提案**: `exact ⟨a, h⟩`
* **凄さ**: 「どの値を使えばこの述語が成り立つか」という、人間が頭を使うべき「実例の選定」を、Leanがコンテキストから推論して提示してくれます。

---

### 2. 暗黙の引数 `{ }` と `@`：数学的構造の解剖

一階述語論理でよく使う「反射律 `rfl`」や「推移律 `trans`」などは、実は大量の**暗黙の引数**を持っています。

* **通常時**: `Eq.refl x`
* **`@` をつけた時**: `#check @Eq.refl`
→ `∀ {α : Sort u} (a : α), a = a`
（実は「どの型（宇宙）の話をしているか」という `{α}` が隠れています）

**デバッグでの活用シーン：**
「見た目は同じ `x = x` なのに、なぜか証明が通らない！」という時、`@` をつけて表示させると、片方の `x` は `Nat`（自然数）型で、もう片方の `x` は `Int`（整数）型だった……というような**型の食い違い（型不一致）を暴く**ことができます。

---

### 3. 一階述語論理の「項モード」で差が出る `@` の使い所

一階述語論理の定理を引数として渡す際、Leanの推論が賢すぎて、逆に困ることがあります。

* **例**: `Int.add_comm` は `∀ x y, x + y = y + x` です。
* 通常は `Int.add_comm a b` と書けば  になります。
* しかし、**「この定理自体を変形させたい（高階の操作）」**ときなどは、`@Int.add_comm` と書いて、まだ  が適用されていない「真っさらな関数状態」であることを明示する必要があります。

---

### 💡 初級者から熟練者への「項モード」視点

一階述語論理を項モードで書くことは、**「証明を組み立てる」というより「データを整理する」感覚**に近いです。

| ツール | 中級者（命題論理） | 熟練者（一階述語論理） |
| --- | --- | --- |
| **`exact?`** | 定理の名前を思い出す | **証拠品（値）の組み合わせ**を教えてもらう |
| **`_` (ホール)** | 命題の証明を保留する | **具体的な値（ や ）**の選定をLeanに丸投げする |
| **`@`** | 型をチラ見する | **数式がどの集合（型）の上で定義されているか**を厳密にチェックする |

---

### 実践してみましょう！

この「暗黙の引数」や「推論」のパワーを体感するために、**演習 9.7.1** を項モードの最短コードで書いてみます。

```lean
-- 演習 9.7.1
variable (A : Type) (f : A → A) (P : A → Prop)
variable (h : ∀ x, P x → P (f x))

example : ∀ y, P y → P (f (f y)) :=
  fun y hy ↦ h (f y) (h y hy)

```

**この一行の解説（対話の跡）:**

1. `fun y hy ↦ _` と書いて、`Expected type: P (f (f y))` を見る。
2. 手元の `h` は「ある値 `x` とその証明 `P x`」を渡すと `P (f x)` をくれる関数。
3. `P (f (f y))` を作るには、`h` の `x` 部分に `f y` を入れれば良さそうだ。
4. `h (f y) _` と書くと、次の穴は `Expected: P (f y)` になる。
5. `P (f y)` は、再び `h` に `y` と `hy` を渡せば手に入る。
6. 完成！

## 💡 一階述語論理版：磨き上げのチェックリスト

* [ ] **`Exists.intro` を `⟨ ⟩` に置き換えたか？**
* [ ] **多重の `∃` は `⟨x, y, ...⟩` とまとめたか？**
* [ ] **`h x` の結果に対して直接 `.left` や `.right` を繋げたか？**
* [ ] **不要な `show` や `have` を削って一行（One-liner）にできないか検討したか？**
